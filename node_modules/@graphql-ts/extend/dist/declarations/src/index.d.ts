/**
 * An API to extend an arbitrary {@link GraphQLSchema} with `@graphql-ts/schema`.
 * Note if you're building a schema entirely with `@graphql-ts/schema`, you
 * shouldn't use this package. This is useful when you have a
 * {@link GraphQLSchema} from somewhere else and you want to some fields to
 * various places in it.
 *
 * See {@link extend} for more details.
 *
 * @module
 */
import { Field, OutputType, ObjectType, InputObjectType, Arg, InputType, EnumType, EnumValue, UnionType, InterfaceType, InterfaceField, ScalarType } from "@graphql-ts/schema";
import { GraphQLSchema } from "graphql";
import * as wrap from "./wrap";
export { wrap };
/**
 * `extend` allows you to extend a {@link GraphQLSchema} with `@graphql-ts/schema`.
 *
 * ```ts
 * const originalSchema = new GraphQLSchema({ ...etc });
 *
 * const extendedSchema = extend({
 *   query: {
 *     hello: graphql.field({
 *       type: graphql.String,
 *       resolve() {
 *         return "Hello!";
 *       },
 *     }),
 *   },
 * })(originalSchema);
 * ```
 *
 * To use existing types from the schema you're extending, you can provide a
 * function and use the {@link BaseSchemaMeta} passed into the function to use
 * existing types in the schema.
 *
 * ```ts
 * const originalSchema = new GraphQLSchema({ ...etc });
 *
 * const extendedSchema = extend((base) => ({
 *   query: {
 *     something: graphql.field({
 *       type: base.object("Something"),
 *       resolve() {
 *         return { something: true };
 *       },
 *     }),
 *   },
 * }))(originalSchema);
 * ```
 *
 * See {@link BaseSchemaMeta} for how to get other types from the schema
 *
 * `extend` will currently throw an error if the query or mutation types are
 * used in other types like this. This will be allowed in a future version.
 *
 * ```graphql
 * type Query {
 *   thing: Query
 * }
 * ```
 */
export declare function extend(extension: Extension | readonly Extension[] | ((base: BaseSchemaMeta) => Extension | readonly Extension[])): (schema: GraphQLSchema) => GraphQLSchema;
/**
 * Any
 *
 * Note the distinct usages of `any` vs `unknown` is intentional.
 *
 * - The `unknown` used for the source type is because the source isn't known and
 *   it shouldn't generally be used here because these fields are on the query
 *   and mutation types
 * - The first `any` used for the `Args` type parameter is used because `Args` is
 *   invariant so only `Record<string, Arg<InputType, boolean>>` would work with
 *   it. The arguable unsafety here doesn't really matter because people will
 *   always use `graphql.field`
 * - The `any` in `OutputType` and the last type argument mean that a field that
 *   requires any context can be provided. This is unsafe, the only way this
 *   could arguably be made more "safe" is by making this unknown which would
 *   requiring casting or make `extend` and etc. generic over a `Context` but
 *   given this is immediately used on an arbitrary {@link GraphQLSchema} so the
 *   type would immediately be thrown away, it would be pretty much pointless.
 */
declare type FieldsOnAnything = {
    [key: string]: Field<unknown, any, OutputType<any>, string, any>;
};
/**
 * An extension to a GraphQL schema. This currently only supports adding fields
 * to the query and mutation types. Extending other types will be supported in
 * the future.
 */
export declare type Extension = {
    /**
     * Extra fields to be added to the query type.
     *
     * ```ts
     * const extension: Extension = {
     *   query: {
     *     isLoggedIn: graphql.field({
     *       type: graphql.Boolean,
     *       resolve(source, args, context, info) {
     *         // ...
     *       },
     *     }),
     *   },
     * };
     * ```
     */
    query?: FieldsOnAnything;
    /**
     * Extra fields to be added to the mutation type.
     *
     * ```ts
     * const extension: Extension = {
     *   mutation: {
     *     createPost: graphql.field({
     *       type: graphql.Boolean,
     *       resolve(source, args, context, info) {
     *         // ...
     *       },
     *     }),
     *   },
     * };
     * ```
     */
    mutation?: FieldsOnAnything;
};
/**
 * This object contains the schema being extended and functions to get wrapped
 *
 * Note that the just like {@link wrap}, all of the GraphQL types returned
 */
export declare type BaseSchemaMeta = {
    schema: GraphQLSchema;
    /**
     * Gets an object type from the existing GraphQL schema and wraps it in an
     * {@link ObjectType}. If there is no object type in the existing schema with
     * the name passed, an error will be thrown.
     *
     * ```ts
     * const originalSchema = new GraphQLSchema({ ...etc });
     *
     * const extendedSchema = extend((base) => ({
     *   query: {
     *     something: graphql.field({
     *       type: base.object("Something"),
     *       resolve() {
     *         return { something: true };
     *       },
     *     }),
     *   },
     * }))(originalSchema);
     * ```
     */
    object(name: string): ObjectType<unknown, unknown>;
    /**
     * Gets an input object type from the existing GraphQL schema and wraps it in
     * an {@link InputObjectType}. If there is no input object type in the existing
     * schema with the name passed, an error will be thrown.
     *
     * ```ts
     * const originalSchema = new GraphQLSchema({ ...etc });
     *
     * const extendedSchema = extend((base) => ({
     *   query: {
     *     something: graphql.field({
     *       type: graphql.String,
     *       args: {
     *         something: graphql.field({
     *           type: base.inputObject("Something"),
     *         }),
     *       },
     *       resolve(source, { something }) {
     *         console.log(something);
     *         return "";
     *       },
     *     }),
     *   },
     * }))(originalSchema);
     * ```
     */
    inputObject(name: string): InputObjectType<{
        [key: string]: Arg<InputType, boolean>;
    }>;
    /**
     * Gets an enum type from the existing GraphQL schema and wraps it in an
     * {@link EnumType}. If there is no enum type in the existing schema with the
     * name passed, an error will be thrown.
     *
     * ```ts
     * const originalSchema = new GraphQLSchema({ ...etc });
     *
     * const extendedSchema = extend((base) => ({
     *   query: {
     *     something: graphql.field({
     *       type: base.enum("Something"),
     *       args: {
     *         something: graphql.field({
     *           type: base.enum("Something"),
     *         }),
     *       },
     *       resolve(source, { something }) {
     *         return something;
     *       },
     *     }),
     *   },
     * }))(originalSchema);
     * ```
     */
    enum(name: string): EnumType<Record<string, EnumValue<unknown>>>;
    /**
     * Gets a union type from the existing GraphQL schema and wraps it in an
     * {@link UnionType}. If there is no union type in the existing schema with the
     * name passed, an error will be thrown.
     *
     * ```ts
     * const originalSchema = new GraphQLSchema({ ...etc });
     *
     * const extendedSchema = extend((base) => ({
     *   query: {
     *     something: graphql.field({
     *       type: base.union("Something"),
     *       resolve() {
     *         return { something: true };
     *       },
     *     }),
     *   },
     * }))(originalSchema);
     * ```
     */
    union(name: string): UnionType<unknown, unknown>;
    /**
     * Gets an interface type from the existing GraphQL schema and wraps it in an
     * {@link InterfaceType}. If there is no interface type in the existing schema
     * with the name passed, an error will be thrown.
     *
     * ```ts
     * const originalSchema = new GraphQLSchema({ ...etc });
     *
     * const extendedSchema = extend((base) => ({
     *   query: {
     *     something: graphql.field({
     *       type: base.interface("Something"),
     *       resolve() {
     *         return { something: true };
     *       },
     *     }),
     *   },
     * }))(originalSchema);
     * ```
     */
    interface(name: string): InterfaceType<unknown, Record<string, InterfaceField<any, OutputType<unknown>, unknown>>, unknown>;
    /**
     * Gets a scalar type from the existing GraphQL schema and wraps it in an
     * {@link ScalarType}. If there is no scalar type in the existing schema with
     * the name passed, an error will be thrown.
     *
     * If the name of a built-in scalar type is passed, an error will also be thrown.
     *
     * ```ts
     * const originalSchema = new GraphQLSchema({ ...etc });
     *
     * const extendedSchema = extend((base) => ({
     *   query: {
     *     something: graphql.field({
     *       type: base.scalar("JSON"),
     *       args: {
     *         something: graphql.field({
     *           type: base.scalar("JSON"),
     *         }),
     *       },
     *       resolve(source, { something }) {
     *         return something;
     *       },
     *     }),
     *   },
     * }))(originalSchema);
     * ```
     */
    scalar(name: string): ScalarType<unknown>;
};
//# sourceMappingURL=index.d.ts.map