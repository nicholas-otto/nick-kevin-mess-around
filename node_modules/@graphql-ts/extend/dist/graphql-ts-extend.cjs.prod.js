'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var schema = require('@graphql-ts/schema');
var graphql = require('graphql');
var apiWithoutContext = require('@graphql-ts/schema/api-without-context');

/**
 * Utilties to wrap named `graphql-js` types into `@graphql-ts/schema` types.
 * Note that when using these functions, you're not provided with a lot of the
 * guarantees that `@graphql-ts/schema` will normally provide since the values
 * passed in don't include the necessary type information. These functions
 * return GraphQL types that accept/can be used as any type and can be used with
 * any context. If you know more specific types for the GraphQL types, you
 * should cast them with `as`.
 *
 * @module
 */

/**
 * Wraps an existing {@link GraphQLObjectType} into a {@link ObjectType} so that
 * it can be used in a GraphQL schema built with `@graphql-ts/schema`.
 *
 * ```ts
 * // this will likely be obtained from some existing GraphQLSchema
 * const someObjectType = new GraphQLObjectType({ ...etc });
 *
 * graphql.field({
 *   type: wrap.object(someObjectType),
 *   resolve() {
 *     // ...
 *   },
 * });
 * ```
 */
function object(graphQLType) {
  return {
    kind: "object",
    graphQLType,
    __context: undefined,
    __source: undefined
  };
}
/**
 * Wraps an existing {@link GraphQLInputObjectType} into a {@link InputObjectType}
 * so that it can be used in a GraphQL schema built with `@graphql-ts/schema`.
 *
 * ```ts
 * // this will likely be obtained from some existing GraphQLSchema
 * const someInputObjectType = new GraphQLInputObjectType({ ...etc });
 *
 * graphql.field({
 *   type: graphql.String,
 *   args: {
 *     something: graphql.arg({ type: someInputObjectType }),
 *   },
 *   resolve(source, { something }) {
 *     console.log(something);
 *     // ...
 *   },
 * });
 * ```
 */

function inputObject(graphQLType) {
  return {
    kind: "input",
    __context: undefined,
    __fields: undefined,
    graphQLType
  };
}
/**
 * Wraps an existing {@link GraphQLEnumType} into a {@link EnumType} so that it
 * can be used in a GraphQL schema built with `@graphql-ts/schema`.
 *
 * ```ts
 * // this will likely be obtained from some existing GraphQLSchema
 * const someEnumType = new GraphQLEnumType({ ...etc });
 *
 * graphql.field({
 *   type: wrap.enum(someEnumType),
 *   args: {
 *     something: graphql.arg({ type: wrap.enum(someEnumType) }),
 *   },
 *   resolve(source, { something }) {
 *     console.log(something);
 *     // ...
 *   },
 * });
 * ```
 */

function enumType(graphQLType) {
  return {
    kind: "enum",
    __context: undefined,
    graphQLType,
    values: Object.fromEntries(graphQLType.getValues().map(value => {
      var _value$deprecationRea, _value$description;

      return [value.name, {
        value: value.value,
        deprecationReason: (_value$deprecationRea = value.deprecationReason) !== null && _value$deprecationRea !== void 0 ? _value$deprecationRea : undefined,
        description: (_value$description = value.description) !== null && _value$description !== void 0 ? _value$description : undefined
      }];
    }))
  };
}
/**
 * Wraps an existing {@link GraphQLUnionType} into a {@link UnionType} so that it
 * can be used in a GraphQL schema built with `@graphql-ts/schema`.
 *
 * ```ts
 * // this will likely be obtained from some existing GraphQLSchema
 * const someUnionType = new GraphQLUnionType({ ...etc });
 *
 * graphql.field({
 *   type: wrap.union(someUnionType),
 *   resolve() {
 *     // ...
 *   },
 * });
 * ```
 */

function union(graphQLType) {
  return {
    kind: "union",
    __context: undefined,
    __source: undefined,
    graphQLType
  };
}
/**
 * Wraps an existing {@link GraphQLInterfaceType} into a {@link InterfaceType} so
 * that it can be used in a GraphQL schema built with `@graphql-ts/schema`.
 *
 * ```ts
 * // this will likely be obtained from some existing GraphQLSchema
 * const someInterfaceType = new GraphQLInterfaceType({ ...etc });
 *
 * graphql.field({
 *   type: wrap.interface(someInterfaceType),
 *   resolve() {
 *     // ...
 *   },
 * });
 * ```
 */

function interfaceType(graphQLType) {
  return {
    kind: "interface",
    __context: undefined,
    __source: undefined,
    __fields: undefined,
    graphQLType
  };
}

var wrap = /*#__PURE__*/Object.freeze({
  __proto__: null,
  object: object,
  inputObject: inputObject,
  'enum': enumType,
  union: union,
  'interface': interfaceType,
  scalar: apiWithoutContext.scalar
});

/**
 * An API to extend an arbitrary {@link GraphQLSchema} with `@graphql-ts/schema`.
 * Note if you're building a schema entirely with `@graphql-ts/schema`, you
 * shouldn't use this package. This is useful when you have a
 * {@link GraphQLSchema} from somewhere else and you want to some fields to
 * various places in it.
 *
 * See {@link extend} for more details.
 *
 * @module
 */
const builtinScalars = new Set(graphql.specifiedScalarTypes.map(x => x.name));
/**
 * `extend` allows you to extend a {@link GraphQLSchema} with `@graphql-ts/schema`.
 *
 * ```ts
 * const originalSchema = new GraphQLSchema({ ...etc });
 *
 * const extendedSchema = extend({
 *   query: {
 *     hello: graphql.field({
 *       type: graphql.String,
 *       resolve() {
 *         return "Hello!";
 *       },
 *     }),
 *   },
 * })(originalSchema);
 * ```
 *
 * To use existing types from the schema you're extending, you can provide a
 * function and use the {@link BaseSchemaMeta} passed into the function to use
 * existing types in the schema.
 *
 * ```ts
 * const originalSchema = new GraphQLSchema({ ...etc });
 *
 * const extendedSchema = extend((base) => ({
 *   query: {
 *     something: graphql.field({
 *       type: base.object("Something"),
 *       resolve() {
 *         return { something: true };
 *       },
 *     }),
 *   },
 * }))(originalSchema);
 * ```
 *
 * See {@link BaseSchemaMeta} for how to get other types from the schema
 *
 * `extend` will currently throw an error if the query or mutation types are
 * used in other types like this. This will be allowed in a future version.
 *
 * ```graphql
 * type Query {
 *   thing: Query
 * }
 * ```
 */

function extend(extension) {
  return schema => {
    const getType = name => {
      const graphQLType = schema.getType(name);

      if (graphQLType == null) {
        throw new Error(`No type named ${JSON.stringify(name)} exists in the schema that is being extended`);
      }

      return graphQLType;
    };

    const resolvedExtension = flattenExtensions(typeof extension === "function" ? extension({
      schema,

      object(name) {
        const graphQLType = getType(name);

        if (!graphql.isObjectType(graphQLType)) {
          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an object type`);
        }

        return object(graphQLType);
      },

      inputObject(name) {
        const graphQLType = getType(name);

        if (!graphql.isInputObjectType(graphQLType)) {
          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an input object type`);
        }

        return inputObject(graphQLType);
      },

      enum(name) {
        const graphQLType = getType(name);

        if (!graphql.isEnumType(graphQLType)) {
          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an enum type`);
        }

        return enumType(graphQLType);
      },

      interface(name) {
        const graphQLType = getType(name);

        if (!graphql.isInterfaceType(graphQLType)) {
          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not an interface type`);
        }

        return interfaceType(graphQLType);
      },

      scalar(name) {
        if (builtinScalars.has(name)) {
          throw new Error(`The names of built-in scalars cannot be passed to BaseSchemaInfo.scalar but ${name} was passed`);
        }

        const graphQLType = getType(name);

        if (!graphql.isScalarType(graphQLType)) {
          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not a scalar type`);
        }

        return apiWithoutContext.scalar(graphQLType);
      },

      union(name) {
        const graphQLType = getType(name);

        if (!graphql.isUnionType(graphQLType)) {
          throw new Error(`There is a type named ${JSON.stringify(name)} in the schema being extended but it is not a union type`);
        }

        return union(graphQLType);
      }

    }) : extension);
    const queryType = schema.getQueryType();
    const mutationType = schema.getMutationType();
    const typesToFind = new Set();

    if (queryType) {
      typesToFind.add(queryType);
    }

    if (mutationType) {
      typesToFind.add(mutationType);
    }

    const usages = findObjectTypeUsages(schema, typesToFind);

    if (usages.size) {
      throw new Error(`@graphql-ts/extend doesn't yet support using the query and mutation types in other types but\n${[...usages].map(([type, usages]) => {
        return `- ${JSON.stringify(type)} is used at ${usages.map(x => JSON.stringify(x)).join(", ")}`;
      }).join("\n")}`);
    }

    if (!resolvedExtension.mutation && !resolvedExtension.query) {
      return schema;
    }

    const newQueryType = extendObjectType(queryType, resolvedExtension.query || {}, "Query");
    const newMutationType = extendObjectType(mutationType, resolvedExtension.mutation || {}, "Mutation");
    const schemaConfig = schema.toConfig();
    let types = [...(queryType || !newQueryType ? [] : [newQueryType]), ...(mutationType || !newMutationType ? [] : [newMutationType]), ...schemaConfig.types.map(type => {
      if (newQueryType && type.name === (queryType === null || queryType === void 0 ? void 0 : queryType.name)) {
        return newQueryType;
      }

      if (newMutationType && type.name === (mutationType === null || mutationType === void 0 ? void 0 : mutationType.name)) {
        return newMutationType;
      }

      return type;
    })];
    const updatedSchema = new graphql.GraphQLSchema({ ...schemaConfig,
      query: newQueryType,
      mutation: newMutationType,
      types
    });
    return updatedSchema;
  };
}

function printFieldOnType(type, fieldName) {
  const printed = graphql.printType(type);
  const document = graphql.parse(printed);
  const parsed = document.definitions[0];
  const parsedField = parsed.fields.find(x => x.name.value === fieldName);
  return graphql.print(parsedField);
}

function extendObjectType(existingType, fieldsToAdd, defaultName) {
  const hasNewFields = Object.entries(fieldsToAdd).length;

  if (!hasNewFields) {
    return existingType;
  }

  const existingTypeConfig = existingType === null || existingType === void 0 ? void 0 : existingType.toConfig();
  const newFields = { ...(existingTypeConfig === null || existingTypeConfig === void 0 ? void 0 : existingTypeConfig.fields)
  };

  for (const [key, val] of Object.entries(getGraphQLJSFieldsFromGraphQLTSFields(fieldsToAdd))) {
    if (newFields[key]) {
      var _name;

      throw new Error(`The schema extension defines a field ${JSON.stringify(key)} on the ${JSON.stringify((_name = existingType.name) !== null && _name !== void 0 ? _name : defaultName)} type but that type already defines a field with that name.\nThe original field:\n${printFieldOnType(existingType, key)}\nThe field added by the extension:\n${printFieldOnType(new graphql.GraphQLObjectType({
        name: "ForError",
        fields: {
          [key]: val
        }
      }), key)}`);
    }

    newFields[key] = val;
  }

  return new graphql.GraphQLObjectType({
    name: defaultName,
    ...existingTypeConfig,
    fields: newFields
  });
} // https://github.com/microsoft/TypeScript/issues/17002


const isReadonlyArray = Array.isArray;
const operations = ["query", "mutation"];

function flattenExtensions(extensions) {
  if (isReadonlyArray(extensions)) {
    const resolvedExtension = {
      mutation: {},
      query: {}
    };

    for (const extension of extensions) {
      for (const operation of operations) {
        const fields = extension[operation];

        if (fields) {
          for (const [key, val] of Object.entries(fields)) {
            if (resolvedExtension[operation][key]) {
              throw new Error(`More than one extension defines a field named ${JSON.stringify(key)} on the ${operation} type.\nThe first field:\n${printFieldOnType(schema.graphql.object()({
                name: "ForError",
                fields: {
                  [key]: val
                }
              }).graphQLType, key)}\nThe second field:\n${printFieldOnType(schema.graphql.object()({
                name: "ForError",
                fields: {
                  [key]: resolvedExtension[operation][key]
                }
              }).graphQLType, key)}`);
            }

            resolvedExtension[operation][key] = val;
          }
        }
      }
    }

    return resolvedExtension;
  }

  return extensions;
}
/**
 * Any
 *
 * Note the distinct usages of `any` vs `unknown` is intentional.
 *
 * - The `unknown` used for the source type is because the source isn't known and
 *   it shouldn't generally be used here because these fields are on the query
 *   and mutation types
 * - The first `any` used for the `Args` type parameter is used because `Args` is
 *   invariant so only `Record<string, Arg<InputType, boolean>>` would work with
 *   it. The arguable unsafety here doesn't really matter because people will
 *   always use `graphql.field`
 * - The `any` in `OutputType` and the last type argument mean that a field that
 *   requires any context can be provided. This is unsafe, the only way this
 *   could arguably be made more "safe" is by making this unknown which would
 *   requiring casting or make `extend` and etc. generic over a `Context` but
 *   given this is immediately used on an arbitrary {@link GraphQLSchema} so the
 *   type would immediately be thrown away, it would be pretty much pointless.
 */


function getGraphQLJSFieldsFromGraphQLTSFields(fields) {
  return schema.graphql.object()({
    name: "Something",
    fields
  }).graphQLType.toConfig().fields;
}

function findObjectTypeUsages(schema, types) {
  const usages = new Map();

  for (const [name, type] of Object.entries(schema.getTypeMap())) {
    if (graphql.isInterfaceType(type) || graphql.isObjectType(type)) {
      for (const [fieldName, field] of Object.entries(type.getFields())) {
        const namedType = graphql.getNamedType(field.type);

        if (graphql.isObjectType(namedType) && types.has(namedType)) {
          getOrDefault(usages, namedType, []).push(`${name}.${fieldName}`);
        }
      }
    }

    if (graphql.isUnionType(type)) {
      for (const member of type.getTypes()) {
        if (types.has(member)) {
          getOrDefault(usages, member, []).push(name);
        }
      }
    }
  }

  return usages;
}

function getOrDefault(input, key, defaultValue) {
  if (!input.has(key)) {
    input.set(key, defaultValue);
    return defaultValue;
  }

  return input.get(key);
}

exports.extend = extend;
exports.wrap = wrap;
