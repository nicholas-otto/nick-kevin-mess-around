import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import { useState, Fragment } from 'react';
import { jsx, Text, Stack } from '@keystone-ui/core';
import { FieldContainer, FieldLabel, Select, MultiSelect } from '@keystone-ui/fields';
import { SegmentedControl } from '@keystone-ui/segmented-control';
import { Button } from '@keystone-ui/button';
import { C as CellContainer } from '../../../../../dist/CellContainer-4ad0d6e2.esm.js';
import { C as CellLink } from '../../../../../dist/CellLink-6f915a3a.esm.js';
import '@babel/runtime/helpers/defineProperty';
import '@keystone-ui/icons/icons/AlertTriangleIcon';
import 'next/link';
import '@keystone-ui/toast';
import '@keystone-ui/loading';
import '@keystone-ui/modals';
import 'apollo-upload-client';
import '@emotion/hash';
import '../../../../../dist/sqlite-11f2ae03.esm.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import '../../../../../dist/graphql-ts-schema-ecd3b4c2.esm.js';
import '@apollo/client';
import '../../../../../dist/admin-meta-graphql-4f7bd0cb.esm.js';
import '@babel/runtime/helpers/extends';
import 'next/router';
import '@keystone-ui/popover';
import '@keystone-ui/icons/icons/MoreHorizontalIcon';
import '@keystone-ui/icons/icons/ChevronRightIcon';
import '../../../../../dist/SignoutButton-f3ebfffb.esm.js';
import 'fast-deep-equal';
import '@keystone-ui/notice';
import '../../../../../admin-ui/router/dist/keystone-6-core-admin-ui-router.esm.js';
import 'decimal.js';
import '@graphql-tools/schema';
import '@graphql-ts/schema/api-without-context';
import '@graphql-ts/schema';
import 'graphql-type-json';
import 'graphql-upload/public/GraphQLUpload.js';
import 'graphql';
import '@graphql-ts/extend';
import '@graphql-ts/schema/api-with-context';

const Field = _ref => {
  let {
    field,
    value,
    onChange,
    autoFocus,
    forceValidation
  } = _ref;
  const [hasChanged, setHasChanged] = useState(false);
  const validationMessage = (hasChanged || forceValidation) && !validate(value, field.isRequired) ? jsx(Text, {
    color: "red600",
    size: "small"
  }, field.label, " is required") : null;
  return jsx(FieldContainer, {
    as: field.displayMode === 'select' ? 'div' : 'fieldset'
  }, field.displayMode === 'select' ? jsx(Fragment, null, jsx(FieldLabel, {
    htmlFor: field.path
  }, field.label), jsx(Select, {
    id: field.path,
    isClearable: true,
    autoFocus: autoFocus,
    options: field.options,
    isDisabled: onChange === undefined,
    onChange: newVal => {
      onChange === null || onChange === void 0 ? void 0 : onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: newVal
      }));
      setHasChanged(true);
    },
    value: value.value,
    portalMenu: true
  }), validationMessage) : jsx(Fragment, null, jsx(FieldLabel, {
    as: "legend"
  }, field.label), jsx(Stack, {
    across: true,
    gap: "small",
    align: "center"
  }, jsx(SegmentedControl, {
    segments: field.options.map(x => x.label),
    selectedIndex: value.value ? field.options.findIndex(x => x.value === value.value.value) : undefined,
    onChange: index => {
      onChange === null || onChange === void 0 ? void 0 : onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: field.options[index]
      }));
      setHasChanged(true);
    }
  }), value.value !== null && onChange !== undefined && jsx(Button, {
    onClick: () => {
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: null
      }));
      setHasChanged(true);
    }
  }, "Clear")), validationMessage));
};
const Cell = _ref2 => {
  var _field$options$find;

  let {
    item,
    field,
    linkTo
  } = _ref2;
  let value = item[field.path] + '';
  const label = (_field$options$find = field.options.find(x => x.value === value)) === null || _field$options$find === void 0 ? void 0 : _field$options$find.label;
  return linkTo ? jsx(CellLink, linkTo, label) : jsx(CellContainer, null, label);
};
Cell.supportsLinkTo = true;
const CardValue = _ref3 => {
  var _field$options$find2;

  let {
    item,
    field
  } = _ref3;
  let value = item[field.path] + '';
  const label = (_field$options$find2 = field.options.find(x => x.value === value)) === null || _field$options$find2 === void 0 ? void 0 : _field$options$find2.label;
  return jsx(FieldContainer, null, jsx(FieldLabel, null, field.label), label);
};

function validate(value, isRequired) {
  if (isRequired) {
    // if you got null initially on the update screen, we want to allow saving
    // since the user probably doesn't have read access control
    if (value.kind === 'update' && value.initial === null) {
      return true;
    }

    return value.value !== null;
  }

  return true;
}

const controller = config => {
  var _config$fieldMeta$def, _optionsWithStringVal;

  const optionsWithStringValues = config.fieldMeta.options.map(x => ({
    label: x.label,
    value: x.value.toString()
  })); // Transform from string value to type appropriate value

  const t = v => v === null ? null : config.fieldMeta.type === 'integer' ? parseInt(v) : v;

  const stringifiedDefault = (_config$fieldMeta$def = config.fieldMeta.defaultValue) === null || _config$fieldMeta$def === void 0 ? void 0 : _config$fieldMeta$def.toString();
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: config.path,
    defaultValue: {
      kind: 'create',
      value: (_optionsWithStringVal = optionsWithStringValues.find(x => x.value === stringifiedDefault)) !== null && _optionsWithStringVal !== void 0 ? _optionsWithStringVal : null
    },
    type: config.fieldMeta.type,
    displayMode: config.fieldMeta.displayMode,
    isRequired: config.fieldMeta.isRequired,
    options: optionsWithStringValues,
    deserialize: data => {
      for (const option of config.fieldMeta.options) {
        if (option.value === data[config.path]) {
          const stringifiedOption = {
            label: option.label,
            value: option.value.toString()
          };
          return {
            kind: 'update',
            initial: stringifiedOption,
            value: stringifiedOption
          };
        }
      }

      return {
        kind: 'update',
        initial: null,
        value: null
      };
    },
    serialize: value => {
      var _value$value$value, _value$value;

      return {
        [config.path]: t((_value$value$value = (_value$value = value.value) === null || _value$value === void 0 ? void 0 : _value$value.value) !== null && _value$value$value !== void 0 ? _value$value$value : null)
      };
    },
    validate: value => validate(value, config.fieldMeta.isRequired),
    filter: {
      Filter(props) {
        return jsx(MultiSelect, {
          onChange: props.onChange,
          options: optionsWithStringValues,
          value: props.value,
          autoFocus: true
        });
      },

      graphql: _ref4 => {
        let {
          type,
          value: options
        } = _ref4;
        return {
          [config.path]: {
            [type === 'not_matches' ? 'notIn' : 'in']: options.map(x => t(x.value))
          }
        };
      },

      Label(_ref5) {
        let {
          type,
          value
        } = _ref5;

        if (!value.length) {
          return type === 'not_matches' ? `is set` : `has no value`;
        }

        if (value.length > 1) {
          const values = value.map(i => i.label).join(', ');
          return type === 'not_matches' ? `is not in [${values}]` : `is in [${values}]`;
        }

        const optionLabel = value[0].label;
        return type === 'not_matches' ? `is not ${optionLabel}` : `is ${optionLabel}`;
      },

      types: {
        matches: {
          label: 'Matches',
          initialValue: []
        },
        not_matches: {
          label: 'Does not match',
          initialValue: []
        }
      }
    }
  };
};

export { CardValue, Cell, Field, controller };
