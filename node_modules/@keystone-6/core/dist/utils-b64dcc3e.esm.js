import prompts from 'prompts';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import path__default from 'path';

// prompts also returns an undefined value on SIGINT which we really just want to exit on

async function confirmPromptImpl(message) {
  let initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const {
    value
  } = await prompts({
    name: 'value',
    type: 'confirm',
    message,
    initial
  });

  if (value === undefined) {
    process.exit(1);
  }

  return value;
}

async function textPromptImpl(message) {
  const {
    value
  } = await prompts({
    name: 'value',
    type: 'text',
    message
  });

  if (value === undefined) {
    process.exit(1);
  }

  return value;
}

let shouldPrompt = process.stdout.isTTY && !process.env.SKIP_PROMPTS;
let confirmPrompt = confirmPromptImpl;
let textPrompt = textPromptImpl; // we could do this with jest.mock but i find jest.mock unpredictable and this is much easier to understand

function getConfigPath(cwd) {
  return path__default.join(cwd, 'keystone');
}
function getAdminPath(cwd) {
  return path__default.join(cwd, '.keystone/admin');
}
class ExitError extends Error {
  constructor(code) {
    super(`The process should exit with ${code}`);

    _defineProperty(this, "code", void 0);

    this.code = code;
  }

}

export { ExitError as E, getAdminPath as a, confirmPrompt as c, getConfigPath as g, shouldPrompt as s, textPrompt as t };
