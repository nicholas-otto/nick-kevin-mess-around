import { createServer } from 'http';
import cors from 'cors';
import express from 'express';
import { graphqlUploadExpress } from 'graphql-upload';
import { createSessionContext } from '../session/dist/keystone-6-core-session.esm.js';
import { D as DEFAULT_FILES_STORAGE_PATH, a as DEFAULT_IMAGES_STORAGE_PATH } from './initConfig-2c06899a.esm.js';
import { a as createApolloServerExpress } from './createApolloServer-2aead844.esm.js';
import url from 'url';
import path__default from 'path';

const defaults = {
  healthCheckPath: '/_healthcheck'
};

const addHealthCheck = async _ref => {
  var _config$server;

  let {
    config,
    server
  } = _ref;
  if (!((_config$server = config.server) !== null && _config$server !== void 0 && _config$server.healthCheck)) return;
  const healthCheck = config.server.healthCheck === true ? {} : config.server.healthCheck;
  const path = healthCheck.path || defaults.healthCheckPath;
  server.use(path, (req, res) => {
    const data = (typeof healthCheck.data === 'function' ? healthCheck.data() : healthCheck.data) || {
      status: 'pass',
      timestamp: Date.now()
    };
    res.json(data);
  });
};

/*
NOTE: This creates the main Keystone express server, including the
GraphQL API, but does NOT add the Admin UI middleware.

The Admin UI takes a while to build for dev, and is created separately
so the CLI can bring up the dev server early to handle GraphQL requests.
*/

const DEFAULT_MAX_FILE_SIZE = 200 * 1024 * 1024; // 200 MiB

const addApolloServer = async _ref => {
  var _config$server, _config$graphql;

  let {
    server,
    config,
    graphQLSchema,
    createContext,
    sessionStrategy,
    graphqlConfig
  } = _ref;
  const apolloServer = createApolloServerExpress({
    graphQLSchema,
    createContext,
    sessionStrategy,
    graphqlConfig
  });
  const maxFileSize = ((_config$server = config.server) === null || _config$server === void 0 ? void 0 : _config$server.maxFileSize) || DEFAULT_MAX_FILE_SIZE;
  server.use(graphqlUploadExpress({
    maxFileSize
  }));
  await apolloServer.start();
  apolloServer.applyMiddleware({
    app: server,
    path: ((_config$graphql = config.graphql) === null || _config$graphql === void 0 ? void 0 : _config$graphql.path) || '/api/graphql',
    cors: false
  });
  return apolloServer;
};

const createExpressServer = async (config, graphQLSchema, createContext) => {
  var _config$server2, _config$server3, _config$server4;

  const expressServer = express();
  const httpServer = createServer(expressServer);

  if ((_config$server2 = config.server) !== null && _config$server2 !== void 0 && _config$server2.cors) {
    // Setting config.server.cors = true will provide backwards compatible defaults
    // Otherwise, the user can provide their own config object to use
    const corsConfig = typeof config.server.cors === 'boolean' ? {
      origin: true,
      credentials: true
    } : config.server.cors;
    expressServer.use(cors(corsConfig));
  }

  addHealthCheck({
    config,
    server: expressServer
  });

  if ((_config$server3 = config.server) !== null && _config$server3 !== void 0 && _config$server3.extendExpressApp) {
    const createRequestContext = async (req, res) => createContext({
      sessionContext: config.session ? await createSessionContext(config.session, req, res, createContext) : undefined,
      req
    });

    await config.server.extendExpressApp(expressServer, createRequestContext);
  }

  if ((_config$server4 = config.server) !== null && _config$server4 !== void 0 && _config$server4.extendHttpServer) {
    var _config$server5;

    const createRequestContext = async (req, res) => createContext({
      sessionContext: config.session ? await createSessionContext(config.session, req, res, createContext) : undefined,
      req
    });

    (_config$server5 = config.server) === null || _config$server5 === void 0 ? void 0 : _config$server5.extendHttpServer(httpServer, createRequestContext);
  }

  if (config.files) {
    var _config$files$local$s, _config$files$local;

    expressServer.use('/files', express.static((_config$files$local$s = (_config$files$local = config.files.local) === null || _config$files$local === void 0 ? void 0 : _config$files$local.storagePath) !== null && _config$files$local$s !== void 0 ? _config$files$local$s : DEFAULT_FILES_STORAGE_PATH));
  }

  if (config.images) {
    var _config$images$local$, _config$images$local;

    expressServer.use('/images', express.static((_config$images$local$ = (_config$images$local = config.images.local) === null || _config$images$local === void 0 ? void 0 : _config$images$local.storagePath) !== null && _config$images$local$ !== void 0 ? _config$images$local$ : DEFAULT_IMAGES_STORAGE_PATH));
  }

  const apolloServer = await addApolloServer({
    server: expressServer,
    config,
    graphQLSchema,
    createContext,
    sessionStrategy: config.session,
    graphqlConfig: config.graphql
  });
  return {
    expressServer,
    apolloServer,
    httpServer
  };
};

const adminErrorHTMLFilepath = path__default.join(path__default.dirname(require.resolve('@keystone-6/core/package.json')), 'static', 'admin-error.html');
const createAdminUIMiddleware = async (config, createContext, dev, projectAdminPath) => {
  var _ui$publicPages;

  /** We do this to stop webpack from bundling next inside of next */
  const {
    ui,
    graphql,
    session
  } = config;
  const _next = 'next';

  const next = require(_next);

  const app = next({
    dev,
    dir: projectAdminPath
  });
  const handle = app.getRequestHandler();
  await app.prepare();
  const publicPages = (_ui$publicPages = ui === null || ui === void 0 ? void 0 : ui.publicPages) !== null && _ui$publicPages !== void 0 ? _ui$publicPages : [];
  return async (req, res) => {
    const {
      pathname
    } = url.parse(req.url);

    if (pathname !== null && pathname !== void 0 && pathname.startsWith('/_next') || pathname === ((graphql === null || graphql === void 0 ? void 0 : graphql.path) || '/api/graphql') || pathname === '/api/__keystone_api_build') {
      handle(req, res);
      return;
    }

    try {
      var _ui$pageMiddleware;

      const context = createContext({
        sessionContext: session ? await createSessionContext(session, req, res, createContext) : undefined,
        req
      });
      const isValidSession = ui !== null && ui !== void 0 && ui.isAccessAllowed ? await ui.isAccessAllowed(context) : session ? context.session !== undefined : true;
      const shouldRedirect = await (ui === null || ui === void 0 ? void 0 : (_ui$pageMiddleware = ui.pageMiddleware) === null || _ui$pageMiddleware === void 0 ? void 0 : _ui$pageMiddleware.call(ui, {
        context,
        isValidSession
      }));

      if (shouldRedirect) {
        res.header('Cache-Control', 'no-cache, max-age=0');
        res.header('Location', shouldRedirect.to);
        res.status(302);
        res.send();
        return;
      }

      if (!isValidSession && !publicPages.includes(url.parse(req.url).pathname)) {
        app.render(req, res, '/no-access');
      } else {
        handle(req, res);
      }
    } catch (e) {
      console.error('An error occurred handling a request for the Admin UI:', e);
      res.status(500);
      res.format({
        'text/html': function () {
          res.sendFile(adminErrorHTMLFilepath);
        },
        'application/json': function () {
          res.send({
            error: true
          });
        },
        default: function () {
          res.send('An error occurred handling a request for the Admin UI.');
        }
      });
    }
  };
};

export { createAdminUIMiddleware as a, createExpressServer as c, defaults as d };
