var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  executeSeedCommand: () => executeSeedCommand,
  getSeedCommandFromPackageJson: () => getSeedCommandFromPackageJson,
  legacyTsNodeScriptWarning: () => legacyTsNodeScriptWarning,
  verifySeedConfigAndReturnMessage: () => verifySeedConfigAndReturnMessage
});
var import_debug = __toModule(require("@prisma/debug"));
var import_sdk = __toModule(require("@prisma/sdk"));
var import_chalk = __toModule(require("chalk"));
var import_execa = __toModule(require("execa"));
var import_fs = __toModule(require("fs"));
var import_has_yarn = __toModule(require("has-yarn"));
var import_path = __toModule(require("path"));
var import_pkg_up = __toModule(require("pkg-up"));
var import_util = __toModule(require("util"));
var __defProp2 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
const debug = (0, import_debug.default)("prisma:migrate:seed");
const readFileAsync = (0, import_util.promisify)(import_fs.default.readFile);
async function verifySeedConfigAndReturnMessage(schemaPath) {
  var _a;
  const cwd = process.cwd();
  const detected = detectSeedFiles(cwd, schemaPath);
  const prismaConfig = await (0, import_sdk.getPrismaConfigFromPackageJson)(cwd);
  if (prismaConfig && ((_a = prismaConfig.data) == null ? void 0 : _a.seed)) {
    return void 0;
  }
  const packageManager = (0, import_has_yarn.default)() ? "yarn add -D" : "npm i -D";
  let message = `${import_chalk.default.red('To configure seeding in your project you need to add a "prisma.seed" property in your package.json with the command to execute it:')}

1. Open the package.json of your project
`;
  if (detected.numberOfSeedFiles) {
    await legacyTsNodeScriptWarning();
    message += `2. Add the following example to it:`;
    if (detected.js) {
      message += `
\`\`\`
"prisma": {
  "seed": "node ${detected.js}"
}
\`\`\`
`;
    } else if (detected.ts) {
      message += `
\`\`\`
"prisma": {
  "seed": "ts-node ${detected.ts}"
}
\`\`\`
If you are using ESM (ECMAScript modules):
\`\`\`
"prisma": {
  "seed": "node --loader ts-node/esm ${detected.ts}"
}
\`\`\`

3. Install the required dependencies by running:
${import_chalk.default.green(`${packageManager} ts-node typescript @types/node`)}
`;
    } else if (detected.sh) {
      message += `
\`\`\`
"prisma": {
  "seed": "${detected.sh}"
}
\`\`\`
And run \`chmod +x ${detected.sh}\` to make it executable.`;
    }
  } else {
    message += `2. Add one of the following examples to your package.json:

${import_chalk.default.bold("TypeScript:")}
\`\`\`
"prisma": {
  "seed": "ts-node ./prisma/seed.ts"
}
\`\`\`
If you are using ESM (ECMAScript modules):
\`\`\`
"prisma": {
  "seed": "node --loader ts-node/esm ./prisma/seed.ts"
}
\`\`\`

And install the required dependencies by running:
${packageManager} ts-node typescript @types/node

${import_chalk.default.bold("JavaScript:")}
\`\`\`
"prisma": {
  "seed": "node ./prisma/seed.js"
}
\`\`\`

${import_chalk.default.bold("Bash:")}
\`\`\`
"prisma": {
  "seed": "./prisma/seed.sh"
}
\`\`\`
And run \`chmod +x prisma/seed.sh\` to make it executable.`;
  }
  message += `
More information in our documentation:
${(0, import_sdk.link)("https://pris.ly/d/seeding")}`;
  return message;
}
__name(verifySeedConfigAndReturnMessage, "verifySeedConfigAndReturnMessage");
__name2(verifySeedConfigAndReturnMessage, "verifySeedConfigAndReturnMessage");
async function getSeedCommandFromPackageJson(cwd) {
  var _a;
  const prismaConfig = await (0, import_sdk.getPrismaConfigFromPackageJson)(cwd);
  debug({ prismaConfig });
  if (!prismaConfig || !((_a = prismaConfig.data) == null ? void 0 : _a.seed)) {
    return null;
  }
  const seedCommandFromPkgJson = prismaConfig.data.seed;
  if (typeof seedCommandFromPkgJson !== "string") {
    throw new Error(`Provided seed command \`${seedCommandFromPkgJson}\` from \`${import_path.default.relative(cwd, prismaConfig.packagePath)}\` must be of type string`);
  }
  if (!seedCommandFromPkgJson) {
    throw new Error(`Provided seed command \`${seedCommandFromPkgJson}\` from \`${import_path.default.relative(cwd, prismaConfig.packagePath)}\` cannot be empty`);
  }
  return seedCommandFromPkgJson;
}
__name(getSeedCommandFromPackageJson, "getSeedCommandFromPackageJson");
__name2(getSeedCommandFromPackageJson, "getSeedCommandFromPackageJson");
async function executeSeedCommand(command) {
  console.info(`Running seed command \`${import_chalk.default.italic(command)}\` ...`);
  try {
    await import_execa.default.command(command, {
      stdout: "inherit",
      stderr: "inherit"
    });
  } catch (_e) {
    const e = _e;
    debug({ e });
    console.error(import_chalk.default.bold.red(`
An error occured while running the seed command:`));
    console.error(import_chalk.default.red(e.stderr || e));
    return false;
  }
  return true;
}
__name(executeSeedCommand, "executeSeedCommand");
__name2(executeSeedCommand, "executeSeedCommand");
function detectSeedFiles(cwd, schemaPath) {
  let parentDirectory = import_path.default.relative(cwd, import_path.default.join(cwd, "prisma"));
  if (schemaPath) {
    parentDirectory = import_path.default.relative(cwd, import_path.default.dirname(schemaPath));
  }
  const seedPath = import_path.default.join(parentDirectory, "seed.");
  const detected = {
    seedPath,
    numberOfSeedFiles: 0,
    js: "",
    ts: "",
    sh: ""
  };
  const extensions = ["js", "ts", "sh"];
  for (const extension of extensions) {
    const fullPath = seedPath + extension;
    if (!import_fs.default.existsSync(fullPath)) {
      continue;
    }
    detected[extension] = fullPath;
    detected.numberOfSeedFiles++;
  }
  debug({ detected });
  return detected;
}
__name(detectSeedFiles, "detectSeedFiles");
__name2(detectSeedFiles, "detectSeedFiles");
async function legacyTsNodeScriptWarning() {
  const scripts = await getScriptsFromPackageJson();
  if (scripts == null ? void 0 : scripts["ts-node"]) {
    import_sdk.logger.warn(import_chalk.default.yellow(`The "ts-node" script in the package.json is not used anymore since version 3.0 and can now be removed.`));
  }
  return void 0;
}
__name(legacyTsNodeScriptWarning, "legacyTsNodeScriptWarning");
__name2(legacyTsNodeScriptWarning, "legacyTsNodeScriptWarning");
async function getScriptsFromPackageJson(cwd = process.cwd()) {
  try {
    const pkgJsonPath = await (0, import_pkg_up.default)({ cwd });
    if (!pkgJsonPath) {
      return null;
    }
    const pkgJsonString = await readFileAsync(pkgJsonPath, "utf-8");
    const pkgJson = JSON.parse(pkgJsonString);
    const { "ts-node": tsnode } = pkgJson.scripts;
    return { "ts-node": tsnode };
  } catch (e) {
    return null;
  }
}
__name(getScriptsFromPackageJson, "getScriptsFromPackageJson");
__name2(getScriptsFromPackageJson, "getScriptsFromPackageJson");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  executeSeedCommand,
  getSeedCommandFromPackageJson,
  legacyTsNodeScriptWarning,
  verifySeedConfigAndReturnMessage
});
